package main

import (
	"flag"
	"fmt"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

// Types matching the existing ruleset package
type Regex struct {
	Match   string `yaml:"match"`
	Replace string `yaml:"replace"`
}

type KV struct {
	Key   string `yaml:"key"`
	Value string `yaml:"value"`
}

// Rule struct matching the existing ruleset package
type Rule struct {
	Domain  string   `yaml:"domain,omitempty"`
	Domains []string `yaml:"domains,omitempty"`
	Paths   []string `yaml:"paths,omitempty"`
	Headers struct {
		UserAgent     string `yaml:"user-agent,omitempty"`
		XForwardedFor string `yaml:"x-forwarded-for,omitempty"`
		Referer       string `yaml:"referer,omitempty"`
		Cookie        string `yaml:"cookie,omitempty"`
		CSP           string `yaml:"content-security-policy,omitempty"`
	} `yaml:"headers,omitempty"`
	GoogleCache bool    `yaml:"googleCache,omitempty"`
	RegexRules  []Regex `yaml:"regexRules,omitempty"`
	URLMods     struct {
		Domain []Regex `yaml:"domain,omitempty"`
		Path   []Regex `yaml:"path,omitempty"`
		Query  []KV    `yaml:"query,omitempty"`
	} `yaml:"urlMods,omitempty"`
	Injections []struct {
		Position string `yaml:"position,omitempty"`
		Append   string `yaml:"append,omitempty"`
		Prepend  string `yaml:"prepend,omitempty"`
		Replace  string `yaml:"replace,omitempty"`
	} `yaml:"injections,omitempty"`
}

const generatedRulesTemplate = `// Code generated by scripts/generate.go; DO NOT EDIT.

package rulesets

// Rule struct matching the existing ruleset package
type Rule struct {
	Domain  string   `+"`"+`yaml:"domain,omitempty"`+"`"+`
	Domains []string `+"`"+`yaml:"domains,omitempty"`+"`"+`
	Paths   []string `+"`"+`yaml:"paths,omitempty"`+"`"+`
	Headers struct {
		UserAgent     string `+"`"+`yaml:"user-agent,omitempty"`+"`"+`
		XForwardedFor string `+"`"+`yaml:"x-forwarded-for,omitempty"`+"`"+`
		Referer       string `+"`"+`yaml:"referer,omitempty"`+"`"+`
		Cookie        string `+"`"+`yaml:"cookie,omitempty"`+"`"+`
		CSP           string `+"`"+`yaml:"content-security-policy,omitempty"`+"`"+`
	} `+"`"+`yaml:"headers,omitempty"`+"`"+`
	GoogleCache bool `+"`"+`yaml:"googleCache,omitempty"`+"`"+`
	RegexRules  []Regex `+"`"+`yaml:"regexRules,omitempty"`+"`"+`
	URLMods     struct {
		Domain []Regex `+"`"+`yaml:"domain,omitempty"`+"`"+`
		Path   []Regex `+"`"+`yaml:"path,omitempty"`+"`"+`
		Query  []KV    `+"`"+`yaml:"query,omitempty"`+"`"+`
	} `+"`"+`yaml:"urlMods,omitempty"`+"`"+`
	Injections []struct {
		Position string `+"`"+`yaml:"position,omitempty"`+"`"+`
		Append   string `+"`"+`yaml:"append,omitempty"`+"`"+`
		Prepend  string `+"`"+`yaml:"prepend,omitempty"`+"`"+`
		Replace  string `+"`"+`yaml:"replace,omitempty"`+"`"+`
	} `+"`"+`yaml:"injections,omitempty"`+"`"+`
}

// GeneratedRules contains all rules downloaded from ladder-rules repository
var GeneratedRules = []Rule{
{{range .Rules}}	{
		Domain: {{printf "%q" .Domain}},
		Domains: {{printf "%#v" .Domains}},
		Paths: {{printf "%#v" .Paths}},
		Headers: struct {
			UserAgent     string `+"`"+`yaml:"user-agent,omitempty"`+"`"+`
			XForwardedFor string `+"`"+`yaml:"x-forwarded-for,omitempty"`+"`"+`
			Referer       string `+"`"+`yaml:"referer,omitempty"`+"`"+`
			Cookie        string `+"`"+`yaml:"cookie,omitempty"`+"`"+`
			CSP           string `+"`"+`yaml:"content-security-policy,omitempty"`+"`"+`
		}{
			UserAgent:     {{printf "%q" .Headers.UserAgent}},
			XForwardedFor: {{printf "%q" .Headers.XForwardedFor}},
			Referer:       {{printf "%q" .Headers.Referer}},
			Cookie:        {{printf "%q" .Headers.Cookie}},
			CSP:           {{printf "%q" .Headers.CSP}},
		},
		GoogleCache: {{.GoogleCache}},
		RegexRules: []Regex{
{{range .RegexRules}}			{Match: {{printf "%q" .Match}}, Replace: {{printf "%q" .Replace}}},
{{end}}		},
		URLMods: struct {
			Domain []Regex `+"`"+`yaml:"domain,omitempty"`+"`"+`
			Path   []Regex `+"`"+`yaml:"path,omitempty"`+"`"+`
			Query  []KV    `+"`"+`yaml:"query,omitempty"`+"`"+`
		}{
			Domain: []Regex{
{{range .URLMods.Domain}}				{Match: {{printf "%q" .Match}}, Replace: {{printf "%q" .Replace}}},
{{end}}			},
			Path: []Regex{
{{range .URLMods.Path}}				{Match: {{printf "%q" .Match}}, Replace: {{printf "%q" .Replace}}},
{{end}}			},
			Query: []KV{
{{range .URLMods.Query}}				{Key: {{printf "%q" .Key}}, Value: {{printf "%q" .Value}}},
{{end}}			},
		},
		Injections: []struct {
			Position string `+"`"+`yaml:"position,omitempty"`+"`"+`
			Append   string `+"`"+`yaml:"append,omitempty"`+"`"+`
			Prepend  string `+"`"+`yaml:"prepend,omitempty"`+"`"+`
			Replace  string `+"`"+`yaml:"replace,omitempty"`+"`"+`
		}{
{{range .Injections}}			{
				Position: {{printf "%q" .Position}},
				Append:   {{printf "%q" .Append}},
				Prepend:  {{printf "%q" .Prepend}},
				Replace:  {{printf "%q" .Replace}},
			},
{{end}}		},
	},
{{end}}}
`

const generatedTestUrlsTemplate = `// Code generated by scripts/generate.go; DO NOT EDIT.

package rulesets

import (
	"math/rand"
	"time"
)

// TestURLs contains all test URLs from the ruleset
var TestURLs = []string{
{{range .URLs}}	"{{.}}",
{{end}}}

// GetRandomTestURL returns a random test URL
func GetRandomTestURL() string {
	if len(TestURLs) == 0 {
		return ""
	}
	
	rand.Seed(time.Now().UnixNano())
	return TestURLs[rand.Intn(len(TestURLs))]
}
`

func main() {
	genType := flag.String("type", "rules", "Type of file to generate: 'rules' or 'urls'")
	flag.Parse()

	if flag.NArg() != 1 {
		log.Fatalf("Usage: go run scripts/generate.go --type=<type> <rules_directory>")
	}
	rulesDir := flag.Arg(0)

	var allRules []Rule
	var allURLs []string

	err := filepath.WalkDir(rulesDir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if !strings.HasSuffix(path, ".yaml") && !strings.HasSuffix(path, ".yml") {
			return nil
		}

		log.Printf("Processing %s", path)
		data, err := os.ReadFile(path)
		if err != nil {
			return fmt.Errorf("failed to read %s: %w", path, err)
		}

		// Unmarshal into nodes to process for both rules and test URLs
		var nodes []yaml.Node
		err = yaml.Unmarshal(data, &nodes)
		if err != nil {
			// Try unmarshalling as a single document
			var singleNode yaml.Node
			if err2 := yaml.Unmarshal(data, &singleNode); err2 != nil {
				return fmt.Errorf("failed to parse YAML in %s: %w", path, err)
			}
			nodes = append(nodes, singleNode)
		}

		for _, node := range nodes {
			// Extract rules
			var rules []Rule
			if err := node.Decode(&rules); err == nil {
				allRules = append(allRules, rules...)
			}
			// Extract test URLs
			allURLs = append(allURLs, findURLs(&node)...)
		}
		return nil
	})

	if err != nil {
		log.Fatal(err)
	}

	switch *genType {
	case "rules":
		log.Printf("Loaded %d rules total", len(allRules))
		tmpl, err := template.New("rules").Parse(generatedRulesTemplate)
		if err != nil {
			log.Fatal(err)
		}
		templateData := struct{ Rules []Rule }{Rules: allRules}
		if err := tmpl.Execute(os.Stdout, templateData); err != nil {
			log.Fatal(err)
		}
	case "urls":
		log.Printf("Found %d test URLs total", len(allURLs))
		tmpl, err := template.New("urls").Parse(generatedTestUrlsTemplate)
		if err != nil {
			log.Fatal(err)
		}
		templateData := struct{ URLs []string }{URLs: allURLs}
		if err := tmpl.Execute(os.Stdout, templateData); err != nil {
			log.Fatal(err)
		}
	default:
		log.Fatalf("Invalid type flag: %s. Use 'rules' or 'urls'", *genType)
	}
}

// findURLs recursively searches for "tests" keys and extracts "url" values.
func findURLs(node *yaml.Node) []string {
	var urls []string
	if node.Kind == yaml.MappingNode {
		for i := 0; i < len(node.Content); i += 2 {
			keyNode := node.Content[i]
			valueNode := node.Content[i+1]
			if keyNode.Value == "tests" && valueNode.Kind == yaml.SequenceNode {
				for _, testNode := range valueNode.Content {
					if testNode.Kind == yaml.MappingNode {
						for j := 0; j < len(testNode.Content); j += 2 {
							if testNode.Content[j].Value == "url" {
								urls = append(urls, testNode.Content[j+1].Value)
							}
						}
					}
				}
			} else {
				urls = append(urls, findURLs(valueNode)...)
			}
		}
	} else if node.Kind == yaml.SequenceNode {
		for _, itemNode := range node.Content {
			urls = append(urls, findURLs(itemNode)...)
		}
	} else if node.Kind == yaml.DocumentNode {
		for _, itemNode := range node.Content {
			urls = append(urls, findURLs(itemNode)...)
		}
	}
	return urls
}